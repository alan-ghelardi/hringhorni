// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
)

// CanaryAnalysisExecutionRequest CanaryAnalysisExecutionRequest
//
// The canary analysis configuration request object for initiating a canary analysis execution.
//
// swagger:model CanaryAnalysisExecutionRequest
type CanaryAnalysisExecutionRequest struct {

	// The value of analysisIntervalMins is used to calculate how many judgements will occur over the lifetime of the canary analysis execution.
	// If this field is omitted then it will default to lifetime.
	// If this field is set to a value greater than lifetime, it will be reset to lifetime.
	AnalysisIntervalMins int64 `json:"analysisIntervalMins,omitempty"`

	// This is how long the canary analysis execution will wait before beginning the analysis phase. This can be useful in a continuous integration situation where the canary analysis execution is triggered asynchronously and metrics are ready for consumption after a time period.
	BeginAfterMins int64 `json:"beginAfterMins,omitempty"`

	// This is the amount of time in minutes the analysis phase of the canary analysis execution will last. Either this value or endTimeIso (in scopes) must be set.
	LifetimeDurationMins int64 `json:"lifetimeDurationMins,omitempty"`

	// If this optional value is supplied, then the canary analysis execution will perform judgements on a sliding time window. The judgements will be from endTime - lookbackMins to startTime + (judgementNumber * interval). If lookbackMins is not exactly equal to interval, then the metrics analyzed will be overlapping or discontinuous.
	// If this field is omitted, the judgements will be performed on a growing time window, from startTime + to startTime + (judgementNumber * interval).
	//
	LookbackMins int64 `json:"lookbackMins,omitempty"`

	// This is a list of Canary Analysis Execution Request scopes. This directs the Canary Analysis Execution where to find the experiment and control metrics in the metrics source. The list must have at least one value.
	Scopes []*CanaryAnalysisExecutionRequestScope `json:"scopes"`

	// A map of customizable data that among other things can be used in org-specific external modules such as event listeners to handle notifications such as Slack, email, async http callbacks, etc.
	// The contents of this field don't have an effect on the actual canary analysis execution.
	SiteLocal interface{} `json:"siteLocal,omitempty"`

	// The thresholds that will be used for the canary judgements. When multiple judgements are occurring during the lifetime of this execution, the last judgement must have a score that meets or exceeds the pass threshold, all previous judgement scores must meet or exceed the marginal score.
	Thresholds *CanaryClassifierThresholdsConfig `json:"thresholds,omitempty"`
}

// Validate validates this canary analysis execution request
func (m *CanaryAnalysisExecutionRequest) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateScopes(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateThresholds(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *CanaryAnalysisExecutionRequest) validateScopes(formats strfmt.Registry) error {
	if swag.IsZero(m.Scopes) { // not required
		return nil
	}

	for i := 0; i < len(m.Scopes); i++ {
		if swag.IsZero(m.Scopes[i]) { // not required
			continue
		}

		if m.Scopes[i] != nil {
			if err := m.Scopes[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("scopes" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("scopes" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *CanaryAnalysisExecutionRequest) validateThresholds(formats strfmt.Registry) error {
	if swag.IsZero(m.Thresholds) { // not required
		return nil
	}

	if m.Thresholds != nil {
		if err := m.Thresholds.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("thresholds")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("thresholds")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this canary analysis execution request based on the context it is used
func (m *CanaryAnalysisExecutionRequest) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateScopes(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateThresholds(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *CanaryAnalysisExecutionRequest) contextValidateScopes(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.Scopes); i++ {

		if m.Scopes[i] != nil {
			if err := m.Scopes[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("scopes" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("scopes" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *CanaryAnalysisExecutionRequest) contextValidateThresholds(ctx context.Context, formats strfmt.Registry) error {

	if m.Thresholds != nil {
		if err := m.Thresholds.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("thresholds")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("thresholds")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *CanaryAnalysisExecutionRequest) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *CanaryAnalysisExecutionRequest) UnmarshalBinary(b []byte) error {
	var res CanaryAnalysisExecutionRequest
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
